# Что является базой языка?
Простая математика, переменные, функции, классы и юзы

# Классы, методы и базовая структура программы
## Общее
Тут стандартно. Каждая строка должна оканчиваться `;`, комментарии пишутся после `//`
## Классы
Как и во многих современных языках, кастиэль нацелен на объектно-ориентированное программирование
Классы бывают публичные `public` и приватные `private`
Пустой класс создаётся так:
```
<тип класса> Class <имя класса> {а тут код}
```
Пример:
```Castiel
public Class Main {

}
```
## Методы и функции
Методы это ОЧЕНЬ просто. Из-за структуры языка все функции
```
<тип возвращаемого> fun <имя>(<аргумент1>, <аргумент2...>){//А тут код}
```
В типе возвращаемого можно прописать любой тип данных, либо `void`, если возвращать ничего не надо
Возврат значения совершается с помощью `return`
Пример:
```Castiel
public class Main{
  void fun main(){
    //Опустим факт того, что модуля System еще не существует и вывод будет выглядеть по-другому
    write('Я не знаю, зачем я это складываю ' + Counter.count(1,2)); //Выведет "Я не знаю, зачем я это складываю 3"
  }
}
private class Counter{
  int fun count(a, b){
    return a + b;
  }
}
```
## Юзы
Юз делается очень просто:
```
use <нужные класс и метод> as <имя в данной программе>
```
Пример использования:
```Castiel
use Math.mod as mod;

public Class Main{
  //Опустим отсутствие модуля system и math, потом адаптирую под них
  write(mod(10,4));
}
```

# Типы данных
Кастиэль является языком с со статической типизацией. Следовательно, в языке имеется определенное количество типов данных. Типы данных в языке схожи с Java, однако, не во всех случаях
Названия типов не более 3х символов, такая уж стилизация

### Встроенные типы данных
Тип | Диапазон значений | Пояснение
--- | --- | --- 
int | +-2 147 483 647 | Обычное число в определенном диапазоне
dbl | 64-разрядное целое | Обычное число в расширенном диапазоне
flt | 3.4e+-038 | Дробное число в определенном диапазоне
bln | true/false (1/0) | Булев тип данных (ИСТИНА или ЛОЖЬ)
chr | Символ Unicode | Один!! символ в Unicode
str | Любые знаки Unicode | Массив символов в Unicode
arr | Любые данные | Массив различных типов данных
### Создание своего типа данных
Для регистрации своего типа данных достаточно использовать метод `regType`, включенный в модуль `System`
```
//regType <имяТипа> {
//  <имя>: <тип>
//};
```
```Castiel
regType hmn {
  name: str,
  age: int,
  pets: arr
}
```

# Переменные
Переменные можно и даже нужно объявлять не до начала программы, а прямо в коде, хоть в каждом методе
## Простые переменные
Переменная в кастиэле объявляется с помощью оператора `var`
```
var <имя> (<тип>) = <значение>;
```
###### Примеры для каждого типа данных:
```Castiel
//int
var myCoolInteger (int) = 112534;
//dbl
var myCoolDouble (dbl) = 764372462387462;
//flt
var myCoolFloat (flt) = 35.32176;
//bln
var myCoolBoolean (bln) = true;
//chr
var myCoolCharacter (chr) = 'a';
//str
var myCoolString (str) = 'abcdef';
//Массивов нет, о них будет отдельный разговор
```
Присвоить значение уже существующей переменной так же легко:
```Castiel
myCoolString = 'Я ненавижу этот язык!!';
```

## Массивы
Массивы в данном языке схожи с массивами из многих ЯП. Неудивительно, такой стандарт очень удобен. Создавая массивы, вдохновление пришло из JS, поэтому названия методов могут быть похожи
Создать массив очень легко
```Castiel
//В аргументе указано число элементов массива, этот параметр необязателен
//Массив может содержать элементы любого типа, однако тип должен быть указан
//При указании длины массива, незаполненные части превратятся в null
arr myCoolArray (5) = [0 (int), 'a' (chr), false (bln)]
```
При выводе всех элементов массива из примера мы получим ```0, a, false, null, null```

### Многомерные массивы
У Кастиэля нет инструментария для работы с многомерными массивами, поэтому такой массив будет представлять собой миссив из массивов
```
arr elemOne (3) = [1 (int), 2 (int), 3 (int)];
arr elemTwo (3) = [1 (int), 2 (int), 3 (int)];
arr elemThree (3) = [1 (int), 2 (int), 3 (int)];
arr myCoolArray (3) = [
  elemOne,
  elemTwo,
  elemThree
]
```
### Работа с массивом
* toStr - превращение массива в строку

  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  var tStr (str) = myCoolArray.toStr(); // 1, 2, 3
  ```
* pop - удаляет последний элемент массива и возвращает его
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  write(myCoolArray.pop()); //3
  //Массив превратится в [1, 2]
  ```
* push - добавляет новый элемент в конец массива
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  myCoolArray.push(4);
  //Массив превратится в [1, 2, 3, 4]
  ```
* shift - удаляет первый элемент массива и возвращает его
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  write(myCoolArray.shift()); //1
  //Массив превратится в [2, 3]
  ```
* unshift - добавляет новый элемент в начало массива
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  myCoolArray.unshift(0);
  //Массив превратится в [0, 1, 2, 3]

# Циклы
Позже допишу

# Математические операции
Да-да, путь кто-нибудь еще скажет, что математика не нужна программисту. Если увидите такого человека - не стыдитесь его унижать
Большая часть математики ~~сворована~~ позаимствована из Си-подобных ЯП

## Как по-нормальному считать матешу

* \+ - Сложение двух чисел

  ```var plus (int) = 10 + 12; //22```
* \- - Вычитание первого числа из второго

  ```var minus (int) = 10 - 12; //-2```
* \* - Умножение двух чисел

  ```var multiply (int) = 10 * 12; //120```
* \/ - Разделить первое число на второе
  
  ```var divide (int) = 10 / 12 //0, потому что int```
  
## Алгебра логики
### Логические операторы
* `&&` - логическое "И"
* `||` - логическое "ИЛИ"
* `!` - логическое "НЕ"
* `==` - равно
* `!=` - не равно
* `>` - больше
* `<` - меньше
* `>=` - больше или равно
* `<=` - меньше или равно
### if-else
Я подумываю избавиться от этой конструкции в пользу более удобного ```switch```

Данная конструкция строится так:
```
if(<логическое выражение>){
тут код
}else if(<логическое выражение>){ //необязательная часть

}else{ //необязательная часть

}
```
Пример:
```Castiel
if(true){
//Опустим факт того, что модуль system не готов
write('a');
}
```
### switch
Рекомендуется использовать именно этот вариант, мне он нравится больше if-else лестниц
Свичи делаются проще простого:
```
switch(<сравниваемое>){
  case <значение 1>:
    тут код
  case <значение 2>:
    тут код
  default: //необязателен, требуется если нужно выполнить код
           //когда ни одно из условий не подходит
    тут код
}
```
Пример:
```
switch(x){
  case 1: 
    write('a');
  case 2:
    write('b');
}

switch(true){
  case ((x + y)/10) == 21: 
    write('a');
  case (((x + y)/10) > 21) && ((10 - 2x) < 43):
    write('b');
}
```
