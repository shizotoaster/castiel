# Что является базой языка?
Простая математика, переменные, функции, классы и юзы

# Классы, методы и базовая структура программы
## Общее
Тут стандартно. Каждая строка должна оканчиваться `;`, комментарии пишутся после `//`, комментарии также могут быть многострочны: `/* можно переносить строку! */`
## Классы
Как и во многих современных языках, кастиэль нацелен на объектно-ориентированное программирование
Классы бывают публичные `public` и приватные `private`
Пустой класс создаётся так:
```
<тип класса> Class <имя класса> {а тут код}
```
Пример:
```Castiel
public Class Main {

}
```
* extends
  Классы можно расширить, добавив им функционала (дополнительные методы)
  ```Castiel
  public Class a {
    void fun a(){
    
    }
  }
  
  public Class b extends a{
    void fun b(){
      a();
    }
  }
  ```
* implements
* Позволяет использовать методы класса, а также перезаписывать их с помощью пометки ```@Ovr```
  ```Castiel
  public Class a {
    void fun a(){
    
    }
  }
  
  public Class b {
    void fun b(){
    
    }
  }
  
  public Class c implements a, b{
    void fun c(){
      a();
    }
    @Ovr
    void fun a(){
      write('Это перезапись метода');
    }
  }
  ```
## Методы и функции
Методы это ОЧЕНЬ просто. Из-за структуры языка все функции
```
<тип возвращаемого> fun <имя>(<аргумент1>, <аргумент2...>){//А тут код}
```
В типе возвращаемого можно прописать любой тип данных, либо `void`, если возвращать ничего не надо
Возврат значения совершается с помощью `return`
Пример:
```Castiel
public class Main{
  void fun main(){
    //Опустим факт того, что модуля System еще не существует и вывод будет выглядеть по-другому
    write('Я не знаю, зачем я это складываю ' + Counter.count(1,2)); //Выведет "Я не знаю, зачем я это складываю 3"
  }
}
private class Counter{
  int fun count(a (int), b (int)){
    return a + b;
  }
}
```
## Юзы
Юз делается очень просто:
```
use <нужные класс и метод> as <имя в данной программе>
```
Пример использования:
```Castiel
use Math.mod as mod;

public Class Main{
  //Опустим отсутствие модуля system и math, потом адаптирую под них
  write(mod(10,4));
}
```
## Шаблоны
Принцип работы я ~~украл~~ позаимствовал из С++
```
Tmp TEMP<Тип аргумента arg1, Тип аргумента 2 arg2, ..., Тип аргумента N argN>(){
  //Тут код
}
```

```Castiel
Tmp TEMP<Тип аргумента arg1, Тип аргумента 2 arg2>{
  write(arg1 + ' ' + arg2);
}

TEMP fun intstr((int), (str));

intstr(1, '- это цифра))');

//Выведет "1 - это цифра"
```

# Типы данных
Кастиэль является языком с со статической типизацией. Следовательно, в языке имеется определенное количество типов данных. Типы данных в языке схожи с Java, однако, не во всех случаях
Названия типов не более 3х символов, такая уж стилизация

### Встроенные типы данных
Тип | Диапазон значений | Пояснение
--- | --- | --- 
int | +-2 147 483 647 | Обычное число в определенном диапазоне
dbl | 64-разрядное целое | Обычное число в расширенном диапазоне
flt | 3.4e+-038 | Дробное число в определенном диапазоне
bln | true/false (1/0) | Булев тип данных (ИСТИНА или ЛОЖЬ)
chr | Символ Unicode | Один!! символ в Unicode
str | Любые знаки Unicode | Массив символов в Unicode
arr | Любые данные | Массив различных типов данных
obj | Любые данные | Объект
### Создание своего типа данных
Для регистрации своего типа данных достаточно использовать метод `regType`, включенный в модуль `System`
```
//regType <имяТипа> {
//  <имя>: <тип>
//};
```
```Castiel
regType hmn {
  name: str,
  age: int,
  pets: arr
}
```

# Переменные
Переменные можно и даже нужно объявлять не до начала программы, а прямо в коде, хоть в каждом методе
## Простые переменные
Переменная в кастиэле объявляется с помощью оператора `var`
```
var <имя> (<тип>) = <значение>;
```
###### Примеры для каждого типа данных:
```Castiel
//int
var myCoolInteger (int) = 112534;
//dbl
var myCoolDouble (dbl) = 764372462387462;
//flt
var myCoolFloat (flt) = 35.32176;
//bln
var myCoolBoolean (bln) = true;
//chr
var myCoolCharacter (chr) = 'a';
//str
var myCoolString (str) = 'abcdef';
//Массивов нет, о них будет отдельный разговор, про объекты тоже
```
Присвоить значение уже существующей переменной так же легко:
```Castiel
myCoolString = 'Я ненавижу этот язык!!';
```

## Объекты
Объекты похожи на то, что существует в других языках
Создавая объект, тип данных указывать не нужно, его нужно указывать для ключей
```Castiel
var myCoolObj (obj) = {
  <имя ключа> (<тип данных>): <значение>,
  <имя ключа> (<тип данных>): <значение>,
  <имя ключа> (<тип данных>): <значение>
}
```
```
var myCoolObj (obj) = {
  name (str): 'Artyom',
  age (int): 24,
  isAdult (bln): true
}
```
### Получить данные из объекта
```<имя объекта>.<имя ключа> //Да, все так просто```
Пример:
```
var myCoolObj (obj) = {
  name (str): 'Artyom',
  age (int): 24,
  isAdult (bln): true
}

write(myCoolObj.name); //Artyom
```
### Добавить элемент массива
Для этого достаточно всего лишь присвоить значение несуществующему ключу
```var <имя объекта>.<имя ключа> (<тип данных>) = <значение>;```
Пример:
```
var myCoolObj (obj) = {
  name (str): 'Artyom',
  age (int): 24,
  isAdult (bln): true
}

var myCoolObj.isMarried (bln) = false;

write(myCoolObj); //var myCoolObj (obj) = { name (str): 'Artyom', age (int): 24, isAdult (bln): true, isMarried (bln): false }
```

## Массивы
Массивы в данном языке схожи с массивами из многих ЯП. Неудивительно, такой стандарт очень удобен. Создавая массивы, вдохновление пришло из JS, поэтому названия методов могут быть похожи
Создать массив очень легко
```Castiel
//В аргументе указано число элементов массива, этот параметр необязателен
//Массив может содержать элементы любого типа, однако тип должен быть указан
//При указании длины массива, незаполненные части превратятся в null
arr myCoolArray (5) = [0 (int), 'a' (chr), false (bln)]
```
При выводе всех элементов массива из примера мы получим ```0, a, false, null, null```

### Многомерные массивы
У Кастиэля нет инструментария для работы с многомерными массивами, поэтому такой массив будет представлять собой миссив из массивов
```
arr elemOne (3) = [1 (int), 2 (int), 3 (int)];
arr elemTwo (3) = [1 (int), 2 (int), 3 (int)];
arr elemThree (3) = [1 (int), 2 (int), 3 (int)];
arr myCoolArray (3) = [
  elemOne,
  elemTwo,
  elemThree
]
```
### Работа с массивом
* toStr - превращение массива в строку

  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  var tStr (str) = myCoolArray.toStr(); // 1, 2, 3
  ```
* pop - удаляет последний элемент массива и возвращает его
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  write(myCoolArray.pop()); //3
  //Массив превратится в [1, 2]
  ```
* push - добавляет новый элемент в конец массива
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  myCoolArray.push(4);
  //Массив превратится в [1, 2, 3, 4]
  ```
* shift - удаляет первый элемент массива и возвращает его
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  write(myCoolArray.shift()); //1
  //Массив превратится в [2, 3]
  ```
* unshift - добавляет новый элемент в начало массива
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  myCoolArray.unshift(0);
  //Массив превратится в [0, 1, 2, 3]
  ```
* foreach - перебор элементов массива
  Внутри метода создается анонимная функция
  ```
  arr myCoolArray (3) = [1 (int), 2 (int), 3 (int)];
  myCoolArray(void fun(elem, i, arr){
    write(i + ': ' + elem);
    //0: 1
    //1: 2
    //2: 3
  });
  //i - номер элемента массива, elem - элемент массива, arr - сам массив
  ```

# Циклы
* while
  ```
  while(<условие>){
    //тут код
  }
  ```
  Пример:
  ```Castiel
  while(true){
    write('Кастиэль');
  }
  //Бесконечный вывод слова
  ```
* for
  ```
  for(<начало>;<условие>;<шаг>;){
    //тут код
  }
  ```
  Пример:
  ```
  for(var i (int) = 0;i<5;i+1;){
    write('Кастиэль!');
  }
  //Выведет слово 5 раз
  ```
  
# Математические операции
Да-да, путь кто-нибудь еще скажет, что математика не нужна программисту. Если увидите такого человека - не стыдитесь его унижать
Большая часть математики ~~сворована~~ позаимствована из Си-подобных ЯП

## Как по-нормальному считать матешу

* \+ - Сложение двух чисел

  ```var plus (int) = 10 + 12; //22```
* \- - Вычитание первого числа из второго

  ```var minus (int) = 10 - 12; //-2```
* \* - Умножение двух чисел

  ```var multiply (int) = 10 * 12; //120```
* \/ - Разделить первое число на второе
  
  ```var divide (int) = 10 / 12 //0, потому что int```
  
## Алгебра логики
### Логические операторы
* `&&` - логическое "И"
* `||` - логическое "ИЛИ"
* `!` - логическое "НЕ"
* `==` - равно
* `!=` - не равно
* `>` - больше
* `<` - меньше
* `>=` - больше или равно
* `<=` - меньше или равно
### if-else
Я подумываю избавиться от этой конструкции в пользу более удобного ```switch```

Данная конструкция строится так:
```
if(<логическое выражение>){
тут код
}else if(<логическое выражение>){ //необязательная часть

}else{ //необязательная часть

}
```
Пример:
```Castiel
if(true){
//Опустим факт того, что модуль system не готов
write('a');
}
```
### switch
Рекомендуется использовать именно этот вариант, мне он нравится больше if-else лестниц
Свичи делаются проще простого:
```
switch(<сравниваемое>){
  case <значение 1>:
    тут код
  case <значение 2>:
    тут код
  default: //необязателен, требуется если нужно выполнить код
           //когда ни одно из условий не подходит
    тут код
}
```
Пример:
```
switch(x){
  case 1: 
    write('a');
  case 2:
    write('b');
}

switch(true){
  case ((x + y)/10) == 21: 
    write('a');
  case (((x + y)/10) > 21) && ((10 - 2x) < 43):
    write('b');
}
```
